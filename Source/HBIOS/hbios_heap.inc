;
;==================================================================================================
;   HBIOS HEAP MANAGAMENT
;==================================================================================================
;
; ALLOCATE HL BYTES OF MEMORY ON THE HEAP
; RETURNS POINTER TO ALLOCATED SPACE IN HL
; ON SUCCESS RETURN A == 0, AND Z SET
; ON FAILURE A <> 0 AND NZ SET AND HL IS SET TO FREE AMOUNT OF HEAP
; ALL OTHER REGISTERS PRESERVED
;
; A 4 BYTE HEADER IS PLACED IN FRONT OF THE ALLOCATED MEMORY
;  - DWORD: SIZE OF MEMROY ALLOCATED (DOES NOT INCLUDE 4 BYTE HEADER)
;  - DWORD: POINTER TO PREVIOUS BLOCK (TOP BIT IS SET IF MARKED FOR DELETION)
SYS_ALLOC:
HB_ALLOC:
	; SAVE ALLOC SIZE AND REFERENCE ADR FOR SUBSEQUENT HEADER CONSTRUCTION
	LD	(CB_TMPSZ), HL		; SAVE INCOMING SIZE REQUESTED
;
	; CALC NEW HEAP TOP AND HANDLE OUT-OF-SPACE ERROR
	PUSH	DE			; SAVE INCOMING DE
	LD	DE, 4			; SIZE OF HEADER
	ADD	HL, DE			; ADD IT IN
	JR	C, SYS_ALLOC1		; ERROR ON OVERFLOW
	LD	DE, (CB_HEAPTOP)	; CURRENT HEAP TOP
	ADD	HL, DE			; ADD IT IN, HL := NEW HEAP TOP
	JR	C, SYS_ALLOC1		; ERROR ON OVERFLOW
	BIT	7, H			; TEST PAST END OF BANK (>= 32K)
	JR	NZ, SYS_ALLOC1		; ERROR IF PAST END
;
	; SAVE NEW HEAP TOP
	LD	DE, (CB_HEAPTOP)		; GET ORIGINAL HEAP TOP
	LD	(CB_HEAPTOP), HL		; SAVE NEW HEAP TOP
;
	; SET HEADER VALUES
	EX	DE, HL			; HEADER ADR TO HL
	LD	DE, (CB_TMPSZ)		; GET THE ORIG SIZE REQUESTED

	LD	BC, (CB_HEAPLAST)
	LD	(CB_HEAPLAST), HL	; MARK THIS AS THE LAST BLOCK

	LD	(HL), E			; SAVE SIZE (LSB)
	INC	HL			; BUMP HEADER POINTER
	LD	(HL), D			; SAVE SIZE (MSB)
	INC	HL			; BUMP HEADER POINTER
	LD	(HL), C			; SAVE PREV ADR (LSB)
	INC	HL			; BUMP HEADER POINTER
	LD	(HL), B			; SAVE PREV ADR (MSB)
	INC	HL			; BUMP HEADER POINTER

;
	; RETURN SUCCESS, HL POINTS TO START OF ALLOCATED MEMORY (PAST HEADER)
	POP	DE			; RESTORE INCOMING DE
	RET_SUCCESS
;
SYS_ALLOC1:
	; ERROR RETURN
	CALL	SYS_FREE4
	POP	DE			; RESTORE INCOMING DE
	RET_ERR(ERR_NOMEM)
;
; FREE HEAP MEMORY BY SIMPLY RELEASING ALL
; MEMORY BEYOND POINTER IN HL.
; ON SUCCESS RETURN A == 0, AND Z SET
; ON FAILURE A <> 0 AND NZ SET AND HL TRASHED
; ALL OTHER REGISTERS PRESERVED
; ON RETURN HL IS AMOUNT OF FREE SPACE IN HEAP
;
; HDR:
; 2 WORD SIZE
; 2 WORD PTR TO PREV
SYS_FREE:
	PUSH	DE			; PROTECT DE AND BC
	PUSH	BC

	CALL	SYS_HPVALDPTR
	JR	Z, SYS_FREE1

	CALL	SYS_FREE4

	POP	BC
	POP	DE
	RET_FAIL

SYS_FREE1:
	DEC	HL			; MSB OF PREV ADDR
	LD	A, (HL)
	SET	7, A
	LD	(HL), A			; MARK THIS BLOCK FOR DELETION
	DEC	HL			; FLAGS
;
; GARBAGE COLLECT - REMOVE ALL END BLOCKS MARKED FOR DELETION
;
	LD	HL, (CB_HEAPLAST)	; ADDR OF LAST BLOCK (UNLESS ZERO)

SYS_FREE2:
	LD	A, H
	OR	L
	JP	Z, SYS_FREE3		; NO MORE BLOCKS

	INC	HL
	INC	HL
	INC	HL
	LD	A, (HL)			; TEST FLAG
	BIT	7, A			; IS BLOCK MARKED FOR DELETION?
	JP	Z, SYS_FREE3		; FINISH IS NO MORE BLOCKS FOR DELETION

	DEC	HL			; RESTORE ADDR OF BLOCK
	DEC	HL
	DEC	HL
	LD	(CB_HEAPTOP), HL	; MOVE HEAP END POINTER DOWN TO RELEASE THIS BLOCK
	INC	HL
	INC	HL			;
	INC	HL			;
	LD	A, (HL)			; LOAD ADDR OF PREVIOUS BLOCK (MSB)
	RES	7, A			; TURN OFF DELETION FLAG BIT
	DEC	HL			; LSB OF PREV ADD
	LD	L, (HL)
	LD	H, A
	LD	(CB_HEAPLAST), HL	; SAVE IT
	JP	SYS_FREE2

SYS_FREE3:
	CALL	SYS_FREE4
	POP	BC
	POP	DE
	RET_SUCCESS

; RETURN IN HL AMOUNT OF FREE SPACE LEFT IN HEAP
SYS_FREE4:
	LD	DE, (CB_HEAPTOP)
	LD	HL, $8000
	OR	A
	SBC	HL, DE
	RET
;
; VERIFY THAT THE BLOCK REFENCE IN HL
; IS AN ALLOCATED BLOCK IN THE HEAP
; RETURN Z IF FOUND IN HEAP
SYS_HPVALDPTR:
	PUSH	HL

	EX	DE, HL			; LOAD ADDR INTO DE
	DEC	DE			; AND ADJUST FOR HEADER
	DEC	DE
	DEC	DE
	DEC	DE

	LD      HL, (CB_HEAP)		; START AT HEAP START

SYS_HPVALDPTR1:
	LD	A, (CB_HEAPTOP)		; ARE WE AT TOP
	CP	L
	JR	NZ, SYS_HPVALDPTR2
	LD	A, (CB_HEAPTOP + 1)
	CP	H
	JR	Z, SYS_HPVALDPTR5

SYS_HPVALDPTR2:
	LD	A, H			; TEST IF HL EQUAL TO BLOCK TO BE FREE'D
	CP	D
	JR	NZ, SYS_HPVALDPTR3	; NOT THIS BLOCK
	LD	A, L
	CP	E
	JR	Z, SYS_HPVALDPTR4	; FOUND BLOCK

SYS_HPVALDPTR3:
	LD	C, (HL)
	INC	HL
	LD	B, (HL)
	INC	HL
	INC	HL
	INC	HL
	ADD	HL, BC
	JR	SYS_HPVALDPTR1

SYS_HPVALDPTR4:
	POP	HL
	RET_SUCCESS

SYS_HPVALDPTR5:
	POP	HL
	RET_FAIL
